<div class="content l-constrained" data-role="collapsible-set">
  <div data-role="collapsible">
    <h2 class="beta">1.1 - Technology</h2>
    <p>Android development is different to anything I've done before; I'm experienced with front-end web development, which is relatively open to different implementations and methods of doing things. In contrast, Android has some set ways of achieving a specific aim, most of which are detailed on the <a href="http://developer.android.com">Android Developer</a> website. I enjoyed learning more about Java and Android Studio, and getting more experience with Object-Oriented Progamming.</p>
    <p>Android is written in Java, which is owned by Oracle (historically Sun Microsystems). Large parts are open-source (where the source code is a open and accessible to anyone to edit and change for any purpose) <small class="citation" data-ref-type="book" data-ref-id="4"></small>. However, some are closed-source and only accessible to Oracle, who have been involved in long-running legal battles with Google over their use of private Java code <small class="citation" data-ref-type="website" data-ref-id="1"></small>.
    <p>To develop an Android app, an IDE (integrated development environment) called Android Studio, developed by Google and based on JetBrains' IntelliJ, is used. Previously, Eclipse ADT (Android Developmen Tools) was used.</p>
    <p>Along with Java, Android also uses XML (eXtensible Markup Language) to build the layouts of each interface for the activities, fragments, etc. This can then interact with the Java using Object Types (e.g a TextView) to change the various values, create an event handler for a button being tapped, and many more.</p>
    <p>I have learnt a lot about Object-Oriented Programming, which Android and Java are both very focussed on. Android has many built-in classes developed by Google which are then available to implement and extend to achieve your aims. For example, an Activity (anything which provides the user with a screen where they do something specific <small class="citation" data-ref-type="website" data-ref-id="2"></small>) usually extends an Adnroid class known as <code>AppCombatActivity</code>. Another example is my View Pager Adapter, which is on the Dashboard and switches the view between the List and the Map. To create this, I have extended a class called <code>FragmentPagerAdapter</code> and then specified the fragments to be shown on each tab inside a <code>switch</code> statement.</p>
    <p>I have two databases for my app; one is an SQLLite database which is built into the app, and one is a MySQL database hosted on the server.</p>
    <h3 class="gamma">1.1.1 - SQLLite database</h3>
    <p>The SQLLite database is built into Android and allows for offline access; it holds all my Plaque data, which is currently about 2600 data rows. SQLLite is very small implementation of an SQL database which is made for storing locally. I chose this because I wanted the plaques to be available when the user had no internet connection; this is likely, as they ae likely to be away from a good connection when using the app, due to the nature of it.</p>
    <p>The data for the Plaques came from a website called <a href="http://openplaques.org">OpenPlaques</a>; they provided two JSON files for all the plaques in the UK (about 10,000). The first one listed all the meta data such as subject, inscription, area, address, thumbnail, etc. The second JSON file was a GeoJSON file, which listed all the geo-data for the plaques, and linked it to the first file using a unique ID tag for each plaque. I wrote a small PHP script to combine the two JSON files and deposit it into a MySQL database, which I then converted to an SQLLite database. In the PHP script, I also had a constraint that it should only get Plaques in London (the JSON file had an area property); I decided that 2600 plaques were enough and I wouldn't be able to test the app in places other than London without incovenience.</p>
    <p>Currently the app is showing 20 plaques on the main list by simply getting the first 20 in the database (IDs 1 to 20), however I plan to shortly change this to get them by location and show them in descending order of closeness.</p>
    <p>To show the Plaques, I have used an Android list entity called Recycler View, which is a list view which only stores in memory the cards which are on the screen; this saves memory which means it is more effecient. It is seen when scrolling down the list and the images load only when the user scrolls down to show that card.</p>
    <h3 class="gamma">1.1.2 - Server Side Database</h3>
    <p>My server database holds the User data and the data from the visits and the plaques which the user favourites. In the future, it will also hold the data on plaque collections (plaques which are related to each other (e.g British Prime Ministers)). My user table holds everything related to the user; the email, name, date registered, and crucially, the primary key, which is a unique ID automatically generated by MySQL when a new record is generated. In the favourites table, there are four records - a unique ID (not used anywhere else but has to be there as a primary key) and then the ID of the user who favourited it and the Plaque ID they have favourited, and also the time they favourited the plaque, so the favourites can be shown in descending order (most recent at the top). The user ID is a foreign key to the user table, and the plaque ID would be but because the plaque database is local to Android, it cannot be.</p>
    <p>The server-side code uses Java Servlets as the underlying framework; these are in fact an older technology that aren't used as much these days - the more modern way of doing this would be a Rest API. I used query parameters on the URL so that I could specify data to get and post to the server; because the request is a GET request, it shows the parameters in the URL string - if it was a POST request it would hide them and send them in the header instead.</p>
    <p>To write the Java Servlet code, we used Vi, the default Unix text editor, which is a command-based editor with no mouse input. I use Vim (vi-improved) as my default editor on my Mac, so I'm fairly used to the various keyboard commands, but some were different which was interesting. (I wrote a <a href="https://github.com/tomoakley/unix-vim-commands">help sheet</a> to give my confused coursemates some pointers on how to use the technologies available to us.) I decided early on that editing on the server was slow and pointless (with Vim I have syntax highlighting, and various other plugins to increase my productivity) so I installed Git on the server and pushed my work to a <a href="https://github.com/tomoakley/android-connection-servlet">Git repo</a> and then pushed and pulled my work to get it on the server. Unfortunatley I couldn't figure out how to replicate the Jetty-Ant-Servlet setup on the server so i couldn't test my code locally so had to keep pushing to the server, hence the high number of commits and bug fixing commits I've made to the repo. (Testing live on a server is a bad idea because if your code has any vulnerabilities, it may crash the server or a hacker may be able to gain access to the data or server.)</p>
    <h3 class="gamma">1.1.3 - Connecting to the server from Android</h3>
    <p>To connect to the server, I used <a href="http://squareup.com">Square</a>'s library called <a href="http://square.github.io/okhttp/">OkHttp</a>, which makes it very easy to do asynchronous requests to a server. Android won't allow synchronous requests on the main UI thread because if it fails to return it will freeze and crash the app, which is obviously bad for users. Instead, Android encourages Asynchronous requests, which means that the method containing the request returns before the data from the request is returned.</p>
    <p>I have added two links below to images which will show in a jQuery Mobile popup, which demonstrate the code I have used to connect to the server using OkHttp.</p>
    <a href="#getRequest" data-rel="popup" data-transition="flow">Building the request</a>
    <div data-role="popup" id="getRequest">
      <img src="assets/images/code/getRequest-android.png" alt="getRequest method for connecting to the server" class="float-left" />
    </div>
    <a href="#asyncCallback" data-rel="popup" data-transition="flow">Asynchronous Callback</a>
    <div data-role="popup" id="asyncCallback">
      <img src="assets/images/code/async-callback.png" alt="Asynchronous Callback function using OkHttp" class="float-right" />
    </div>
    <p>The values for these requests are held in a Java data type known as Futures, which are variables which are "promised" some return data in the future but won't hold any until the request has returned, and are then converted to the primitve data type. (In JavaScript, Futures are known as Promises.) A URL with the various parameters is built and then submitted to the OkHttp methods, which then makes the request and returns the data, which is is a JSON format, which is parsed in Android Studio using Google's <a href="https://github.com/google/gson">Gson</a> library.</p>
    <h3 class="gamma">1.1.4 - Improvements to the implementation</h3>
    <p>I'm actually struggling to think of a way to improve this, although I'm sure there are many. I didn't keep a particuarly good focus on the memory usage of the app - it could be quite high and may be something I'll have to look at in the future. Also, I am planning to rent a new server (maybe on AWS or <a href="http://digitalocean.com">Digital Ocean</a> and competely redevelop the backend so that it uses a far more effecient and secure REST API to transfer the data. I plan to do this in JavaScript (using Node.js) as this is pretty standard now and I have experience using this. I also plan to create an iOS app for PlaqueIt at some point because I think it'd be a good introduction to the iOS environment. I would love to keep developing the Android app further and release it on the Google Play Store. Having been to Made in Brunel (and won the Software Engineering prize!) I am excited by this prospect as many people told me that I should do this.</p>
    <p>I also think I could have developed a little faster, to get more features done; I was a little slow at the beginning as I was still reading about Android frameworks from Google and the best way to go about things, and made quite a lot of mistakes at first, which wasted time (but that's the best way to learn programming!).</p>
    <p>I also need to add a catch error for when there is no internet available (or, when the Brunel server is not available!) because currently, the app simply crashes when it cannot connect, which, considering I chose to have the plaques available offline, is not ideal. It will probably just show an error message on the app and disable any features which require network access but hopefully still show the plaques.</p>
    <p>I am planning to add search soon; I will implement this by initially just searching the Subject for the string the user inputs, but I will expand it to location searching as well. Initially my design for bringing up the search box and other related functions (a navigation bar, to change page to Profile, settings, etc) and location search as well) was going to using a dropdown (click on an icon on the app bar and the dropdown would slide down), however I decided this was too complicated and not very "Google-like" in terms of design.</p>
  </div>
  <div data-role="collapsible">
    <h2 class="beta">1.2 - Design</h2>
    <p>UML diagrams and the like are not my strength; I much prefer developing the app in question rather than doing the various theoretical design diagrams before. However, I did produce a Use Case diagram, as can be seen in Figure 1. This shows the (at the time I created it, for Task 1) the three main functions of the app - show a list of plaques, which is extended by multiple features (nearby plaques, visited history, favourites). This is the Recycler View I talked about above - I can re-use this same Recycler and List fragment whenever I want to show a list of my plaques, then plug in a list of plaque objects and it shows them where-ever it's placed. The Use Case diagram also shows that these lists also 'use' the Plaque card item/object - this means that it creates objects for these items <small data-ref-type="book" data-ref-id="3" class="citation"></small>. It also shows the Get Directions to Plaque, which hasn't been added into the app yet; it will however use the plaque data to get the latitude and longitude data and then get directions from your current location. The third one is the routes, or collections, of plaques. Since making this UML diagram, I have changed my view on routes a little - I think giving users a specific route to go through is too specific; simply a collection of plaques which they can visit, and when they complete them all, they get bonus points and a "trophy" or something for doing that collection. While routes would need to use the plaque directions module of the app, a collection wouldn't, as it would just be a list of plaques with the nearest to your current location at the top. I also plan to let users create and share their own collections as well.</p>
    <p>The design of my app is based upon Google's design language called <a href="https://www.google.com/design/spec/material-design/introduction.html">Material Design</a> <small class="citation" data-ref-type="website" data-ref-id="8"></small>; I chose this because it looks native to Android and is largely, a very good design language. It is also implemented heavily in Android and is therefore very easy to use within the IDE.</p>
    <p>I have included some screenshots below of the initial concepts for my app; since then I have changed it quite a lot. The list below highlights my changes:</p>
    <div class="image-grid">
      <div class="image-container">
        <img src="assets/images/design/list-view.jpg" alt="Dashboard view" class="design-img" />
        <span class="image-caption">Figure 1.2.1 - showing the initial design for the dashboard with the list of plaques</span>
      </div>
      <div class="image-container">
        <img src="assets/images/design/plaque.jpg" alt="Plaque Page" class="design-img" />
        <span class="image-caption">Figure 1.2.2 - showing the design of the Plaque page</span>
      </div>
      <div class="image-container">
        <img src="assets/images/design/gestures.jpg" alt="Dashboard showing gestures" class="design-img" />
        <span class="image-caption">Figure 1.2.3 - this is a concept for the dashboard which used gestures on the plaques to do additional actions</span>
      </div>
    </div>
    <ul>
      <li>I have removed the seperators for the list of plaques <small>(Figure 1.2.1)</small>, so it is just a list of plaques with a label showing the distance</li>
      <li>I haven't completed the time for driving, walking, and public transport to the plaque on the Plaque page yet <small>(Figure 1.2.2)</small></li>
      <li>I've removed the "take me there" button on each plaque card <small>(Figure 1.2.1)</small>. Instead the user can simply click on any part of the card to go to the page for that plaque</li>
      <li>There is currently no indicator on a list of plaques, if you have favourited or visited the plaque on the working app <small>(Figure 1.2.1)</small></li>
      <li>I added a tab switcher to switch between list and map view on the main plaque list</li>
      <li>Figure 1.2.3 shows gestures; I wanted to add these but because the tab switching uses a swiping gesture, I couldn't really add any swiping gesturres to each individual plaque</li>
    </ul>
    <p>These designs were created using an application on Mac OS X called <a href="http://sketchapp.com">Sketch</a>, which is a professional design tool for interfaces and websites. I created some sketches, which are viewable in my Task 1 presentation, and computerised these because they looked quite awful when they were simply scanned in, and then went straight on to design. I didn't want to or feel the need to formalise the sketches any further into wireframes.</p>
    <p>I chose to default to the list view on the main Dashboard because I decided that being shown a map when you first enter the app would be a bit confusing. I think it is far more useful to be shown a list of the nearby plaques, and can switch to a map for a different way of looking at that data.</p>
  </div>
  <div data-role="collapsible">
    <h2 class="beta">1.3 - Teamwork</h2>
    <p>The idea of using blue plaques as the subject of our app worked really well; there was enough data for them which made them easy to use and test with, and the app has a lot of different user groups who would be interested (for example, historical societies, scientific-historical societies, geographical interests). Also a lot of different people can be targeteted - students interested in history and London, tourists, and people who want to compete against their friends.</p>
    <p>Team meetings evolved from discusing the app design, potential features and theoretical concepts like UML design to talking about pratical implementations of the back-end code, connecting to the server from Android Studio and hooking the Plaques and data up to the app. Team meetings were useful but at times it also felt like we went round in circles a little, which was annoying. I think the lab sheets and the instructions in them need to be far better structured and written better, from both a technical viewpoint and making them less ambihous, as a lot of things we discussed in our group meetings were the lab sheets and what a particular point or instruction meant.</p>
    <p>Got to be honest; our group didn't really use the wiki and collaboration tools. We relied quite heavily on sharing things on Slack, Dropbox and WhatsApp. Slack is great for team chat as it has so many integrations with other tools such as Trello, Dropbox, etc and can now also do voice and video calls/messages. We were able to share files and discuss about the project and things easily, and get notifications from the team members.</p>
    <p>I think our team were effecient - however due to the way we carried out the implementation of the app, we maybe didn't use our various skillsets as effectively as possible. We each did the Android Studio coding ourselves as we decided it would have been too difficult to each do different bits of the app when we varied so much in programming knowledge and skill. However we did help each other out and did some small presentations to our team if we had completed something which the others didn't understand. In a typical development team, Version Control (typically Git but could also be SVN, Mercurial, etc) would be used and a developer type would do their own part of the app (for example, a front-end developer would work on the consume facing part of the app while the back-end developer would focus on the server, integrations and databases). However, as the skills in the group (and probably most other groups too) was so wide, we couldn't really do that. Personally, for me, I am quite experienced in developing apps and websites so I just carried out the development myself and was quite far ahead of my team. Maybe in hindsight this was wrong but (no offence to my team members) I would have found it very difficult to share the development work because I had my own way of working and developing the app. <small class="citation" data-ref-type="journal" data-ref-id="15"></small></p>
  </div>
  <div data-role="collapsible">
    <h2 class="beta">1.4 - NoSQL Research</h2>
    <p>NoSQL is a type of database which doesn’t store data in a traditional relational database. Instead, it uses a key/value store, rather than the structured rules that govern relational database. In short, there is no schema, or a blueprint of how the database is constructed, in a NoSQL database. This means that a NoSQL database essentially prevents the use of database transactions which would normally be used in an SQL database <small class="citation" data-ref-type="website" data-ref-id="9"></small>.</p>
    <p>Relational databases use the ACID model (Atomicity, Consistency, Isolation, Durability) to maintain reliability. Atomicity is the idea that a transaction is performed completely or not at all; if one part fails, it all fails. Consistency ensures that all data and transactions follow the same rules and no part can be broken. If data is inserted which doesn’t follow the ACID rules, then the database will be rolled back to state where it was consistent with ACID <small class="citation" data-ref-type="website" data-ref-id="10"></small>. Isolation makes sure that transactions happen independently of each other - if two users are logged on to the database and enact a transaction at the same time, the DBMS (Database Management System) will run one before the other to ensure that the data is correct for each query. Finally, Durability makes sure that any transaction is not lost; all actions are logged and backups are used so that the database can be rolled back if the system crashes or data which corrupts the system is inputted.
    <br>
    A NoSQL database does not have these constraints and due to this, is faster as a result <small class="citation" data-ref-type="journal" data-ref-id="13"></small>. Developers are also able to make NoSQL databases fit their own specific needs more as they don’t have these technical constraints.</p>
    <p>NoSQL databases use a model called BASE, instead of ACID, to regulate the operation of the database. BASE, however, is far more flexible and easier to manage than ACID. BASE is comprised of 3 main principles - Basic Availability focusses on the database being available for the maximum amount of time, even through multiple and severe failures. This is achieved by distributing the database across many machines - if one fails, the others should still run and keep at least part of the system online. Soft State is the concept that data consistency should be a developer issue rather than a database problem - this is the exact opposite of ACID, where consistency is a key requirement of the data <small class="citation" data-ref-type="website" data-ref-id="11"></small>.</p>
    <p>The disadvantages of a relational database are clear; while they are extremely reliable and consistent, these constraints also make them slow and, in terms of feature set, large. Many developers who use a relational database say they don’t use many of the features - these features just waste space on the machine and so slows the operation down <small class="citation" data-ref-type="journal" data-ref-id="13"></small>. Also, SQL must be used with a relational database. While SQL is a well-known language, it can also create very large and sometimes difficult to understand queries. It doesn’t work well with the agile approach to software development which most companies now use - if the structure of a database changes (the schema) slightly, an SQL query may have to be updated or even re-written, slowing development of the main product down.
    <br>
    Relational databases are not designed for the partitioning or distribution of data across many servers, as is common now in the age of cloud computing. In Facebook trapped in MySQL ‘fate worse than death’ , Derrick Harris (2011) says that in 2008 Facebook had almost 2000 servers dedicated to running MySQL, and according to Michael Stonebraker, Facebook will have to “bite the bullet and rewrite everything” in order to get out of this “fate worse than death” <small class="citation" data-ref-type="website" data-ref-id="12"></small>. 
    <br>
    Due to this difficulty with distribution, products built on top of a relational database are tough to scale. Scaling comes in two methods - vertical and horizontal. Vertical scaling involves adding more resources (normally storage, processing power and RAM) to a server so that it can handle the load. This is extremely expensive but crucially for a relational database, doesn’t involve any partitioning of data across many servers. Horizontal scaling, which has become increasingly popular with the onset of cloud computing, is when more servers are added to a ‘cluster’ to run a service. Horizontal scaling can be done automatically by the host, which makes it highly efficient as the developer (this role/responsibility is sometimes known as DevOps) doesn’t have to be involved if the application suddenly gets flooded with users (for example, being posted on Hacker News or Product Hunt). Horizontal scaling is also exceptionally cost efficient for the provider, as the servers are usually used by many applications at the same time.
    <br>
    While a distributed relational database is difficult to get right and maintain, it also makes transactions difficult - a transaction that needs to span multiple nodes over multiple servers is going to be inefficient and will be unreliable. Relational databases are being developed which will be better with handling partitioning but it will still be constrained by transactions needing to go across multiple servers <small class="citation" data-ref-type="journal" data-ref-id="14"></small> <small class="citation" data-ref-type="journal" data-ref-id="15"></small>.
    <br>
    Relational databases are also constrained by the data that can be inputted; they are not suitable for data types like documents, multimedia, complex numbers as they do not satisfy the consistency part of the ACID model.</p>
    <p>NoSQL databases have become very popular amongst both large and small companies. They are very easy to scale, both horizontally and vertically, because they are far easier to distribute across multiple servers than a relational database.</p>
    <p>However, while loosing the ACID requirements of the relational model works well, it doesn’t mean that these constraints aren’t needed - instead, the developer of the application needs to write the support for them, increasing development time and maintenance.</p>
    <p>There are 4 different implementations of a NoSQL database. A Key-Value store is the simplest and also the fastest, but does not have the flexibility of more advanced querying. In Java, a Key-Value store is known as a HashMap (or simply Map), and is similar to how JSON (JavaScript Object Notation) stores data. The data is completely unstructured and unordered, making it very small as there is no overhead on the data. Key-Value stores heavily utilise caching which means it is very quick to query and update data. It can hold many types of data, including the primitive types and JSON, objects, etc. Regis is the most popular Key-Value store, as of April 2016 <small class="citation" data-ref-type="website" data-ref-id="16"></small>.</p>
    <p>A Document store is very similar to a Key-Value store, except that a document store has some structure to it’s data. XML, JSON and BSON (Binary representation of JSON) are the most common <small class="citation" data-ref-type="website" data-ref-id="17"></small>. A document is where a key-value pair has nested data inside it, rather than a key-value store which can only hold one value. The most popular document store as of April 2016 is MongoDB <small class="citation" data-ref-type="website" data-ref-id="16"></small> and Couchbase is also very popular <small class="citation" data-ref-type="website" data-ref-id="17"></small>. CouchDB is developed by Apache and uses JavaScript as it’s query language and JSON to store the data. 
    <br>
    Due to document stores and key-value stores having no schema, they are very easy to modify which massively simplifies development and each object can have different fields. Mongo stores data as BSON, which is more efficient for data storage and queries and can store more data types than JSON <small class="citation" data-ref-type="website" data-ref-id="19"></small>.</p>
    <p>A column store database is essentially the reverse of a relational database - it stores the data in columns rather than rows. They extend the simple key-value approach by grouping columns can  together in collections which makes them very fast to extract data and update it. Unlike a relational database, they do not need schemas, or a pre-defined structure, to operate. Instead, each record comes with pre-defined columns and can change between records. Where a relational database stores a row (entry) in different places on the disk, making search/access slower, a column-database stores all the cells for a column as a continuous disk entry, increasing efficiency when searching (Kumar, 2013). Popular column stores are Apache Cassandra, which is based on DynamoDB by Amazon, and Apache HBase, based on BigTable by Google <small class="citation" data-ref-type="website" data-ref-id="21"></small> <small class="citation" data-ref-type="website" data-ref-id="16"></small>. Column stores are highly compressible and partition-able which makes them excellent for horizontal scaling.</p>
    <p>Finally, a Graph database is based on discrete mathematics, utilising nodes and vertices to establish relations between entries. This can be useful for applications where nodes have multiple connections to other nodes and it’s necessary to establish a boundary, for example, friends on a social media site, where it would be inappropriate to store this in rows/columns database. The nodes and relationships between them can store properties, which add additional information to the connection. A relational database can also be used in this way, but a JOIN statement would have to be used <small class="book" data-ref-type="website" data-ref-id="22"></small>, which is slow and inefficient; where a relational database is optimised for highly structured data, a graph database is optimised for very diverse datasets. Neo4j is a popular choice for graph based databases <small class="citation" data-ref-type="website" data-ref-id="16"></small>.</p>
    <p>However, relational databases do have some advantages. They all use SQL, which is almost universally known among software developers and, for simple queries, is easy to understand from just reading it. It is very simple to get some data out of it quickly, for example, “how many people work in the X department?”. Crucially, you do not need to know the question in advance, or spend time writing code to query the database - you can write a query and within a few minutes have a result. All you need to know is how the data relate to each other <small class="citation" data-ref-type="website" data-ref-id="20"></small>. As Voss says, "And when you first start a project, you almost never know all the questions you're going to need to ask. So my advice: always use an RDBMS. Just don't only use an RDBMS.". Further, MongoDB actually lists the equivalent SQL query next to explanations about it’s API - "a pretty clear vote for the usability of SQL" <small class="citation" data-ref-type="website" data-ref-id="20"></small>.</p>
    <p>Relational databases also have advantages over NoSQL when it comes to security; because of the consistency constraint in the ACID model, the data has to be consistent and the transactions have to be completed before the transaction is completed. For a security-conscious application, this is an extremely important consideration, as NoSQL databases have no consistency and no constraint on atomicity. For example, when sending money to someone, first the money must be decreased by the amount in the sender’s account, and then increased by the same amount in the receiver’s account; this results in two SQL queries. If there was a power outage after the first query, then the money has left the sender’s account but not got to the receiver’s account - it’ simply been lost. Atomicity (all or nothing) will make sure this cannot happen. Further, integrity rules, such as constraining a field to only allow numbers bigger than 0, will ensure that a number cannot be -1 (the transaction will fail). If a transaction is completed and it shouldn’t have been, the durability constraint will ensure that the database can be rolled back and the logs produced from the transaction can be examined to find the cause of the error. While NoSQL databases can have these constraints, most don’t by default; they have to be built into the application’s business logic - and they probably won’t be as well implemented as in an RBDMS (Relational Database Management System).</p>
    <p>NoSQL also has some disadvantages; the querying will likely take longer, especially for larger queries. While popular NoSQL databases like Mongo use JavaScript as their query language, you still need to learn to use their API which is time-consuming. Most organisations are unfamiliar with NoSQL will need training, requiring time and resources, to understand what the differences are. The ecosystem for NoSQL is also relatively small - there are far more customer support and management tools for relational databases than for NoSQL. However, a lot of the NoSQL implementations are open-source, which will help as it means that people can contribute to the development of the product and fix bugs quicker and add code for more features.

    <p>Using a NoSQL database could help PlaqueIt immensely; I plan to release PlaqueIt on the Google Play Store, and possibly also develop an iOS app. To scale the app, it will be necessary to use a document store to record the user data. A document store would also be a good way to store the plaque data, seeming as it came in JSON format first - however, there are no plans to add more data to it at the moment, so the scaling advantage of NoSQL isn’t applicable right now. The Plaque database is currently built into Android on an SQLLite database, which is a very small implementation of an SQL database, so the overhead is tiny. I don’t think it is possible to store a document store like Mongo on Android currently. Lastly, I want to continue to allow offline access to the plaque data so I am not keen to put it on the cloud (although if I did, some of the plaque data could be cached locally for offline use).</p>
    <p>However, for the favourites and visited data, a Key-value store would be very good; currently there are 3 columns in these tables - ID, plaque_id and user_id. The ID is simply there as a primary key and is not used otherwise, so is wasting space. A key-value would improve the efficiency of the favourite action, which can be a little slow to work right now (I have no evidence that this is due to the MySQL database, however).</p>
    <p>I have developed a small demo JavaScript app (built on top of Node.js) which utilises MongoDB, a popular document store database. The app simply enters some data for dummy users into the database and logs it to the console. Here is the code with some comments explaining what is going on:</p>
    <ul class="media-list">
      <li>
        <img src="assets/images/code/mongo-code.png" alt="MongoDB Code" class="media-image" />
        <p class="media-content"><small>Figure 1.4.1</small> - This code selects the database to use (“database”) and connects to it, creates a collection (a bit like a table) and then inserts the data. Below can be seen the data which is inserted when the file is run.</p>
      </li>
      <li>
        <img src="assets/images/code/mongo-return.png" alt="Mongo console return" class="media-image" />
        <p class="media-content"><small>Figure 1.4.2</small> - this is the return when the code in Figure 1.4.1 is run. It inserts the fields into the database and prints them out. The ID is a <code>BSON ObjectID</code>, hence the unreadable formatting. To advance this, and actually use in app such as PlaqueIt, it would need to be running a webserver, usually Express (the default Node.js web server module) and return data in the JSON format, like my Servlet currently does. If I decide to take PlaqueIt forward, this is probably the route I will take.</p>
      </li>
    </ul>
    <p>NoSQL databases are excellent for apps and services which need to scale fast, and maybe automatically - if they get unexpected news/social media coverage, for example. The modern web would simply not exist if NoSQL databases had not grown to be able to support their dynamic range of multimedia and other data types. However, relational databases still have a place - as Voss (2010), said, they are very easy to use and simple to implement, but they are incredibly difficult to scale. Due to their ACID constraints, they are still used heavily in the finance industry and anything which requires consistency and atomicity.</p>
  </div>
</div>
